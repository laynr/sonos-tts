# Sonos Text-to-Speech Tool Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a reusable Python CLI tool that discovers Sonos devices on the network and plays text-to-speech messages using Google TTS.

**Architecture:** Three-phase system (discovery, TTS generation, playback) using soco for Sonos control, gTTS for speech synthesis, and a temporary HTTP server to stream audio to the device. Preserves and restores playback state.

**Tech Stack:** Python 3.8+, soco, gTTS, http.server (stdlib), argparse (stdlib)

---

## Task 1: Project Setup and Dependencies

**Files:**
- Create: `requirements.txt`
- Create: `sonos_tts.py`
- Create: `.gitignore`

**Step 1: Create requirements file**

Create `requirements.txt`:

```
soco>=0.30.0
gTTS>=2.5.0
```

**Step 2: Create Python gitignore**

Create `.gitignore`:

```
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
venv/
env/
*.mp3
*.wav
.DS_Store
```

**Step 3: Create main script skeleton**

Create `sonos_tts.py`:

```python
#!/usr/bin/env python3
"""
Sonos Text-to-Speech Tool

Discovers Sonos devices on the network and plays text messages using Google TTS.
"""

import sys

def main():
    """Main entry point for the CLI."""
    print("Sonos TTS Tool - Coming soon!")
    return 0

if __name__ == "__main__":
    sys.exit(main())
```

**Step 4: Make script executable**

Run: `chmod +x sonos_tts.py`

**Step 5: Test basic execution**

Run: `python3 sonos_tts.py`
Expected: "Sonos TTS Tool - Coming soon!"

**Step 6: Commit**

```bash
git add requirements.txt sonos_tts.py .gitignore
git commit -m "feat: initial project setup with dependencies

Add requirements.txt with soco and gTTS dependencies.
Create executable Python script skeleton.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

## Task 2: Device Discovery Implementation

**Files:**
- Modify: `sonos_tts.py`

**Step 1: Add imports and discovery function**

Add to top of `sonos_tts.py`:

```python
import soco
from typing import List, Optional
```

Add function after imports:

```python
def discover_devices(timeout: int = 5) -> List[soco.SoCo]:
    """
    Discover all Sonos devices on the network.

    Args:
        timeout: Maximum time to wait for discovery in seconds

    Returns:
        List of discovered SoCo device objects
    """
    print(f"Discovering Sonos devices (timeout: {timeout}s)...")
    devices = list(soco.discover(timeout=timeout))

    if not devices:
        print("No Sonos devices found. Make sure you're on the same network.")
        return []

    print(f"Found {len(devices)} device(s)")
    return devices
```

**Step 2: Test discovery manually**

Run: `python3 -c "import soco; print(list(soco.discover(timeout=5)))"`
Expected: List of SoCo objects or empty list (depending on network)

**Step 3: Add device selection function**

Add function to `sonos_tts.py`:

```python
def select_device(devices: List[soco.SoCo]) -> Optional[soco.SoCo]:
    """
    Display devices and prompt user to select one.

    Args:
        devices: List of discovered devices

    Returns:
        Selected device or None if cancelled
    """
    if not devices:
        return None

    print("\nAvailable Sonos devices:")
    for idx, device in enumerate(devices, 1):
        player_name = device.player_name
        ip_address = device.ip_address
        print(f"  {idx}. {player_name} ({ip_address})")

    while True:
        try:
            choice = input("\nSelect device number (or 'q' to quit): ").strip()

            if choice.lower() == 'q':
                return None

            idx = int(choice)
            if 1 <= idx <= len(devices):
                selected = devices[idx - 1]
                print(f"Selected: {selected.player_name}")
                return selected
            else:
                print(f"Please enter a number between 1 and {len(devices)}")
        except ValueError:
            print("Invalid input. Enter a number or 'q' to quit.")
        except KeyboardInterrupt:
            print("\nCancelled.")
            return None
```

**Step 4: Update main function to test discovery**

Replace `main()` function:

```python
def main():
    """Main entry point for the CLI."""
    devices = discover_devices()

    if not devices:
        return 1

    device = select_device(devices)

    if not device:
        print("No device selected. Exiting.")
        return 1

    print(f"\nReady to use {device.player_name}")
    return 0
```

**Step 5: Test discovery flow**

Run: `python3 sonos_tts.py`
Expected: Device list displayed, prompt for selection, confirms selection

**Step 6: Commit**

```bash
git add sonos_tts.py
git commit -m "feat: implement Sonos device discovery and selection

Add discover_devices() to scan network for Sonos devices.
Add select_device() for interactive device selection.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

## Task 3: TTS Generation Implementation

**Files:**
- Modify: `sonos_tts.py`

**Step 1: Add TTS imports**

Add to imports section:

```python
from gtts import gTTS
import tempfile
import os
```

**Step 2: Add TTS generation function**

Add function to `sonos_tts.py`:

```python
def generate_tts(text: str, lang: str = 'en') -> Optional[str]:
    """
    Generate TTS audio file from text using Google TTS.

    Args:
        text: Text to convert to speech
        lang: Language code (default: 'en')

    Returns:
        Path to generated MP3 file, or None on failure
    """
    if not text or not text.strip():
        print("Error: Text message cannot be empty")
        return None

    print(f"Generating speech for: '{text}'")

    try:
        tts = gTTS(text=text, lang=lang, slow=False)

        # Create temporary file that won't be auto-deleted
        fd, temp_path = tempfile.mkstemp(suffix='.mp3', prefix='sonos_tts_')
        os.close(fd)  # Close file descriptor, we'll write with gTTS

        tts.save(temp_path)
        print(f"Audio generated: {temp_path}")
        return temp_path

    except Exception as e:
        print(f"Error generating TTS: {e}")
        print("Check your internet connection and try again.")
        return None
```

**Step 3: Test TTS generation manually**

Create test script `test_tts.py`:

```python
from gtts import gTTS
import tempfile
import os

tts = gTTS(text="hello world", lang='en')
fd, path = tempfile.mkstemp(suffix='.mp3')
os.close(fd)
tts.save(path)
print(f"Generated: {path}")
print(f"File size: {os.path.getsize(path)} bytes")
```

Run: `python3 test_tts.py`
Expected: Prints path and file size > 0

Run: `rm test_tts.py`

**Step 4: Update main to include TTS**

Update `main()` function:

```python
def main():
    """Main entry point for the CLI."""
    # Temporary hardcoded message for testing
    message = "Hello world"

    devices = discover_devices()
    if not devices:
        return 1

    device = select_device(devices)
    if not device:
        print("No device selected. Exiting.")
        return 1

    audio_file = generate_tts(message)
    if not audio_file:
        return 1

    print(f"\nReady to play on {device.player_name}")
    print(f"Audio file: {audio_file}")

    # Cleanup temp file
    try:
        os.remove(audio_file)
        print(f"Cleaned up: {audio_file}")
    except Exception as e:
        print(f"Warning: Could not delete temp file: {e}")

    return 0
```

**Step 5: Test TTS integration**

Run: `python3 sonos_tts.py`
Expected: Discovers devices, generates TTS, shows audio file path, cleans up

**Step 6: Commit**

```bash
git add sonos_tts.py
git commit -m "feat: implement Google TTS audio generation

Add generate_tts() to create MP3 files from text using gTTS.
Includes error handling for network issues and empty input.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

## Task 4: HTTP Server for Audio Streaming

**Files:**
- Modify: `sonos_tts.py`

**Step 1: Add HTTP server imports**

Add to imports:

```python
from http.server import HTTPServer, SimpleHTTPRequestHandler
import threading
import socket
```

**Step 2: Add function to get local IP**

Add function:

```python
def get_local_ip() -> str:
    """
    Get the local IP address of this machine.

    Returns:
        Local IP address as string
    """
    try:
        # Connect to external address to determine local IP
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        local_ip = s.getsockname()[0]
        s.close()
        return local_ip
    except Exception:
        return "127.0.0.1"
```

**Step 3: Add HTTP server class and start function**

Add class and function:

```python
class AudioHTTPHandler(SimpleHTTPRequestHandler):
    """Custom HTTP handler that serves a single audio file."""

    audio_file_path = None

    def do_GET(self):
        """Handle GET request for audio file."""
        if self.path == '/audio.mp3':
            try:
                with open(self.audio_file_path, 'rb') as f:
                    self.send_response(200)
                    self.send_header('Content-type', 'audio/mpeg')
                    self.send_header('Content-Length', os.path.getsize(self.audio_file_path))
                    self.end_headers()
                    self.wfile.write(f.read())
            except Exception as e:
                self.send_error(500, f"Error serving file: {e}")
        else:
            self.send_error(404, "File not found")

    def log_message(self, format, *args):
        """Suppress default logging."""
        pass


def start_http_server(audio_file: str, max_attempts: int = 3) -> Optional[tuple]:
    """
    Start HTTP server to serve audio file.

    Args:
        audio_file: Path to audio file to serve
        max_attempts: Maximum number of port attempts

    Returns:
        Tuple of (server, url) or None on failure
    """
    local_ip = get_local_ip()
    AudioHTTPHandler.audio_file_path = audio_file

    for attempt in range(max_attempts):
        try:
            # Try random port between 8000-9000
            port = 8000 + attempt * 100 + (os.getpid() % 100)
            server = HTTPServer((local_ip, port), AudioHTTPHandler)

            # Start server in background thread
            thread = threading.Thread(target=server.serve_forever, daemon=True)
            thread.start()

            url = f"http://{local_ip}:{port}/audio.mp3"
            print(f"HTTP server started: {url}")
            return (server, url)

        except OSError as e:
            if attempt < max_attempts - 1:
                print(f"Port {port} unavailable, retrying...")
                continue
            else:
                print(f"Error starting HTTP server: {e}")
                return None

    return None
```

**Step 4: Test HTTP server manually**

Create test script `test_server.py`:

```python
from gtts import gTTS
import tempfile
import os
import time

# Generate test audio
tts = gTTS(text="test", lang='en')
fd, path = tempfile.mkstemp(suffix='.mp3')
os.close(fd)
tts.save(path)

# Import server function (assuming sonos_tts.py in same dir)
import sys
sys.path.insert(0, '.')
from sonos_tts import start_http_server

# Start server
result = start_http_server(path)
if result:
    server, url = result
    print(f"Server URL: {url}")
    print("Server running for 5 seconds...")
    time.sleep(5)
    server.shutdown()
    print("Server stopped")

os.remove(path)
```

Run: `python3 test_server.py`
Expected: Shows URL, runs for 5s, stops cleanly

Run: `rm test_server.py`

**Step 5: Commit**

```bash
git add sonos_tts.py
git commit -m "feat: implement HTTP server for audio streaming

Add start_http_server() to serve MP3 files to Sonos devices.
Includes automatic port selection and background threading.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

## Task 5: Sonos Playback with State Management

**Files:**
- Modify: `sonos_tts.py`

**Step 1: Add imports for state management**

Add to imports:

```python
import time
from soco.exceptions import SoCoException
```

**Step 2: Add state capture and restore functions**

Add functions:

```python
def capture_state(device: soco.SoCo) -> dict:
    """
    Capture current playback state of Sonos device.

    Args:
        device: SoCo device object

    Returns:
        Dictionary containing state information
    """
    try:
        transport_info = device.get_current_transport_info()
        track_info = device.get_current_track_info()

        state = {
            'transport_state': transport_info['current_transport_state'],
            'track_uri': track_info.get('uri', ''),
            'position': track_info.get('position', '0:00:00'),
            'volume': device.volume,
        }

        print(f"Captured state: {state['transport_state']}")
        return state

    except Exception as e:
        print(f"Warning: Could not capture state: {e}")
        return {}


def restore_state(device: soco.SoCo, state: dict) -> bool:
    """
    Restore previous playback state of Sonos device.

    Args:
        device: SoCo device object
        state: State dictionary from capture_state()

    Returns:
        True if restoration succeeded, False otherwise
    """
    if not state:
        return False

    try:
        # Restore volume
        if 'volume' in state:
            device.volume = state['volume']

        # Restore playback if there was something playing
        if state.get('track_uri') and state['transport_state'] in ['PLAYING', 'PAUSED_PLAYBACK']:
            device.play_uri(state['track_uri'])

            # Seek to position if available
            if state.get('position') and state['position'] != '0:00:00':
                device.seek(state['position'])

            # Resume if it was paused
            if state['transport_state'] == 'PAUSED_PLAYBACK':
                device.pause()

            print("Restored previous playback")
            return True

    except Exception as e:
        print(f"Warning: Could not restore state: {e}")
        return False

    return True
```

**Step 3: Add playback function**

Add function:

```python
def play_on_sonos(device: soco.SoCo, audio_url: str, volume: Optional[int] = None) -> bool:
    """
    Play audio on Sonos device and restore previous state.

    Args:
        device: SoCo device object
        audio_url: HTTP URL to audio file
        volume: Optional volume level (0-100)

    Returns:
        True if playback succeeded, False otherwise
    """
    # Capture current state
    previous_state = capture_state(device)

    try:
        # Set volume if specified
        if volume is not None:
            print(f"Setting volume to {volume}")
            device.volume = volume

        # Play TTS audio
        print(f"Playing on {device.player_name}...")
        device.play_uri(audio_url)

        # Wait for playback to complete
        # Poll transport state until it's no longer playing
        max_wait = 30  # Maximum 30 seconds
        start_time = time.time()

        while time.time() - start_time < max_wait:
            time.sleep(0.5)
            try:
                transport_info = device.get_current_transport_info()
                state = transport_info['current_transport_state']

                if state == 'STOPPED':
                    print("Playback completed")
                    break
            except Exception:
                continue

        # Restore previous state
        time.sleep(0.5)  # Brief pause before restoring
        restore_state(device, previous_state)

        return True

    except SoCoException as e:
        print(f"Error playing on Sonos: {e}")
        # Attempt to restore state even on error
        restore_state(device, previous_state)
        return False
    except Exception as e:
        print(f"Unexpected error: {e}")
        restore_state(device, previous_state)
        return False
```

**Step 4: Update main to integrate playback**

Update `main()` function:

```python
def main():
    """Main entry point for the CLI."""
    message = "Hello world"

    # Discovery
    devices = discover_devices()
    if not devices:
        return 1

    device = select_device(devices)
    if not device:
        print("No device selected. Exiting.")
        return 1

    # Generate TTS
    audio_file = generate_tts(message)
    if not audio_file:
        return 1

    # Start HTTP server
    server_result = start_http_server(audio_file)
    if not server_result:
        os.remove(audio_file)
        return 1

    server, audio_url = server_result

    try:
        # Play on Sonos
        success = play_on_sonos(device, audio_url)

        if not success:
            return 1

    finally:
        # Cleanup
        print("\nCleaning up...")
        server.shutdown()
        time.sleep(0.5)

        try:
            os.remove(audio_file)
        except Exception as e:
            print(f"Warning: Could not delete temp file: {e}")

    print("\nDone!")
    return 0
```

**Step 5: Test full playback flow**

Run: `python3 sonos_tts.py`
Expected: Discovers device, generates audio, plays on Sonos, restores previous state

**Step 6: Commit**

```bash
git add sonos_tts.py
git commit -m "feat: implement Sonos playback with state management

Add play_on_sonos() to play TTS audio on selected device.
Add capture_state() and restore_state() to preserve user's playback.
Integrate full workflow: discover, generate, serve, play, restore.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

## Task 6: CLI Argument Parsing

**Files:**
- Modify: `sonos_tts.py`

**Step 1: Add argparse import**

Import already exists, verify it's at top:

```python
import argparse
```

**Step 2: Add CLI parsing function**

Add function before `main()`:

```python
def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description='Play text-to-speech messages on Sonos devices',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s "Hello world"
  %(prog)s "Welcome home" --volume 50
  %(prog)s "Good morning" --lang en-gb
        """
    )

    parser.add_argument(
        'message',
        help='Text message to speak'
    )

    parser.add_argument(
        '--volume', '-v',
        type=int,
        metavar='N',
        help='Volume level (0-100), defaults to current volume'
    )

    parser.add_argument(
        '--lang', '-l',
        default='en',
        metavar='CODE',
        help='Language code (default: en). Examples: en, en-gb, es, fr, de'
    )

    parser.add_argument(
        '--timeout', '-t',
        type=int,
        default=5,
        metavar='SEC',
        help='Device discovery timeout in seconds (default: 5)'
    )

    args = parser.parse_args()

    # Validate volume
    if args.volume is not None and not (0 <= args.volume <= 100):
        parser.error("Volume must be between 0 and 100")

    return args
```

**Step 3: Update main to use arguments**

Replace `main()` function:

```python
def main():
    """Main entry point for the CLI."""
    args = parse_args()

    # Discovery
    devices = discover_devices(timeout=args.timeout)
    if not devices:
        return 1

    device = select_device(devices)
    if not device:
        print("No device selected. Exiting.")
        return 1

    # Generate TTS
    audio_file = generate_tts(args.message, lang=args.lang)
    if not audio_file:
        return 1

    # Start HTTP server
    server_result = start_http_server(audio_file)
    if not server_result:
        os.remove(audio_file)
        return 1

    server, audio_url = server_result

    try:
        # Play on Sonos
        success = play_on_sonos(device, audio_url, volume=args.volume)

        if not success:
            return 1

    finally:
        # Cleanup
        print("\nCleaning up...")
        server.shutdown()
        time.sleep(0.5)

        try:
            os.remove(audio_file)
        except Exception as e:
            print(f"Warning: Could not delete temp file: {e}")

    print("\nDone!")
    return 0
```

**Step 4: Test CLI with help**

Run: `python3 sonos_tts.py --help`
Expected: Shows usage, arguments, examples

**Step 5: Test CLI with arguments**

Run: `python3 sonos_tts.py "Testing CLI arguments" --volume 30`
Expected: Uses provided message and volume

**Step 6: Test error handling**

Run: `python3 sonos_tts.py "test" --volume 150`
Expected: Error message about volume range

Run: `python3 sonos_tts.py`
Expected: Error about missing message argument

**Step 7: Commit**

```bash
git add sonos_tts.py
git commit -m "feat: add CLI argument parsing

Add argparse for message, volume, language, and timeout options.
Include help text and examples.
Validate volume range (0-100).

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

## Task 7: README Documentation

**Files:**
- Create: `README.md`

**Step 1: Create README**

Create `README.md`:

```markdown
# Sonos Text-to-Speech Tool

A Python CLI tool that plays text-to-speech messages on Sonos devices using Google TTS.

## Features

- Auto-discovers Sonos devices on your network
- Interactive device selection
- High-quality Google Text-to-Speech
- Preserves and restores playback state
- Supports multiple languages
- Volume control

## Requirements

- Python 3.8 or higher
- Sonos device(s) on the same network
- Internet connection (for Google TTS)

## Installation

1. Clone or download this repository

2. Install dependencies:
```bash
pip install -r requirements.txt
```

3. Make the script executable:
```bash
chmod +x sonos_tts.py
```

## Usage

Basic usage:
```bash
python3 sonos_tts.py "Hello world"
```

With volume control:
```bash
python3 sonos_tts.py "Welcome home" --volume 50
```

Different language:
```bash
python3 sonos_tts.py "Bonjour le monde" --lang fr
```

Show help:
```bash
python3 sonos_tts.py --help
```

## Options

- `message` - Text message to speak (required)
- `--volume, -v` - Volume level 0-100 (optional, defaults to current volume)
- `--lang, -l` - Language code (optional, defaults to 'en')
- `--timeout, -t` - Device discovery timeout in seconds (optional, defaults to 5)

## Language Codes

Common language codes for `--lang`:
- `en` - English (US)
- `en-gb` - English (UK)
- `es` - Spanish
- `fr` - French
- `de` - German
- `it` - Italian
- `ja` - Japanese
- `zh` - Chinese

See [gTTS documentation](https://gtts.readthedocs.io/) for full list.

## How It Works

1. Discovers Sonos devices on your network using UPnP
2. Prompts you to select a device
3. Captures current playback state (what's playing, volume, position)
4. Converts your text to speech using Google TTS
5. Starts a temporary local HTTP server
6. Plays the audio on your Sonos device
7. Restores previous playback state
8. Cleans up temporary files and server

## Troubleshooting

**No devices found:**
- Make sure you're on the same WiFi network as your Sonos
- Check firewall settings (UPnP discovery uses UDP)
- Try increasing timeout: `--timeout 10`

**Cannot reach Google TTS:**
- Check your internet connection
- Google TTS is a free service but may have rate limits

**Playback doesn't work:**
- Make sure the Sonos device can reach your computer's IP
- Check that no firewall is blocking the HTTP server (ports 8000-9000)

## License

MIT License - feel free to use and modify as needed.
```

**Step 2: Test README rendering**

Run: `cat README.md`
Expected: Well-formatted markdown

**Step 3: Commit**

```bash
git add README.md
git commit -m "docs: add comprehensive README

Add installation, usage, examples, and troubleshooting guide.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

## Task 8: Final Testing and Edge Cases

**Files:**
- None (testing only)

**Step 1: Test with no network devices**

Disconnect from network or disable WiFi
Run: `python3 sonos_tts.py "test"`
Expected: "No Sonos devices found" message, clean exit

**Step 2: Test with empty message**

Run: `python3 sonos_tts.py ""`
Expected: Argument parsing error

**Step 3: Test with very long message**

Run: `python3 sonos_tts.py "This is a very long message that will test whether the TTS generation and playback can handle extended text without any issues or failures in the system"`
Expected: Works correctly, plays full message

**Step 4: Test with special characters**

Run: `python3 sonos_tts.py "Hello! How are you? Testing... 123 #hashtag @mention"`
Expected: Handles special characters gracefully

**Step 5: Test volume edge cases**

Run: `python3 sonos_tts.py "test" --volume 0`
Expected: Plays at volume 0 (silent), restores previous volume

Run: `python3 sonos_tts.py "test" --volume 100`
Expected: Plays at volume 100 (maximum)

**Step 6: Test different languages**

Run: `python3 sonos_tts.py "Hola mundo" --lang es`
Expected: Spanish TTS voice

Run: `python3 sonos_tts.py "Bonjour" --lang fr`
Expected: French TTS voice

**Step 7: Test Ctrl+C during device selection**

Run: `python3 sonos_tts.py "test"`
Press Ctrl+C when prompted for device
Expected: "Cancelled" message, clean exit

**Step 8: Verify state restoration**

Run: Start playing music on Sonos, note the song and position
Run: `python3 sonos_tts.py "interrupting your music"`
Expected: TTS plays, then original music resumes from where it left off

---

## Task 9: Final Polish and Optional Enhancements

**Files:**
- Modify: `sonos_tts.py` (optional improvements)

**Step 1: Add version constant**

Add at top of `sonos_tts.py` after docstring:

```python
__version__ = "1.0.0"
```

**Step 2: Add version flag to argparse**

In `parse_args()`, add after description:

```python
parser.add_argument(
    '--version',
    action='version',
    version=f'%(prog)s {__version__}'
)
```

**Step 3: Test version flag**

Run: `python3 sonos_tts.py --version`
Expected: Shows version number

**Step 4: Add setup.py for easier installation (optional)**

Create `setup.py`:

```python
from setuptools import setup

with open("README.md", "r") as fh:
    long_description = fh.read()

setup(
    name="sonos-tts",
    version="1.0.0",
    author="Your Name",
    description="Text-to-speech tool for Sonos devices",
    long_description=long_description,
    long_description_content_type="text/markdown",
    py_modules=["sonos_tts"],
    python_requires=">=3.8",
    install_requires=[
        "soco>=0.30.0",
        "gTTS>=2.5.0",
    ],
    entry_points={
        "console_scripts": [
            "sonos-tts=sonos_tts:main",
        ],
    },
    classifiers=[
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
    ],
)
```

**Step 5: Test installation (optional)**

Run: `pip install -e .`
Run: `sonos-tts "Testing installed version"`
Expected: Works as installed command

**Step 6: Final commit**

```bash
git add sonos_tts.py setup.py
git commit -m "feat: add version info and optional pip installation

Add __version__ constant and --version flag.
Add setup.py for pip install support.

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

---

## Success Criteria

- ✅ Script discovers Sonos devices and displays them
- ✅ User can select device interactively
- ✅ Text-to-speech audio generates successfully
- ✅ Audio plays on selected Sonos device
- ✅ Previous playback state is restored
- ✅ CLI arguments work (message, volume, language, timeout)
- ✅ Error handling works for all edge cases
- ✅ Documentation is clear and comprehensive

## Post-Implementation

After completing all tasks, test the complete workflow end-to-end:

1. Run `python3 sonos_tts.py "Final test message" --volume 40`
2. Verify device discovery, selection, TTS generation, playback, and restoration all work
3. Check git log to ensure all commits are clean and descriptive
4. Review README to ensure accuracy

The tool is now complete and ready for use!
